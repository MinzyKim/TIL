



# R 4일차

## 1. 산점도

- 개념 : 
  - 두 개 이상의 변수들 사이의 분포를 점으로 표시한 차트
  - 두 변수의 관계를 시각적으로 분석할 때 유용

```R
price <- runif(10, min=1, max=100)
print(price)
plot(price, col="red")
par(new=T) #차트 추가
line_chart=1:100
#x축은 생성된 난수의 순서,  y축은 
plot(line_chart, type="l", col="red", axes=F, ann=F) #대각선 추가 
```



![1568075396275](./assets/1568075396275.png)

```R
#중복된 데이터의 수만큼 plot점 크기 확대
x<-c(1, 2, 3, 4, 2, 4)
y<-rep(2, 6)
table(x, y)  #빈도수


par(mfrow=c(1, 1))
plot(x, y)
```

![1568075432318](./assets/1568075432318.png)

```R
install.packages("psych")
library(psych)
data(galton)

#child컬럼, parent컬럼을 대상으로 교차테이블을 생성 결과를 데이터프레임으로 생성

galtondf <- as.data.frame(table(galton$child, galton$parent))
head(galtondf)
str(galtondf)

> head(galtondf)
  Var1 Var2 Freq(빈도수)
1 61.7   64    1
2 62.2   64    0
3 63.2   64    2
4 64.2   64    4
5 65.2   64    1
6 66.2   64    2

names(galtondf) <- c("child", "parent", "freq")
  child parent freq
1  61.7     64    1
2  62.2     64    0
3  63.2     64    2
4  64.2     64    4
5  65.2     64    1
6  66.2     64    2

parent <- as.numeric(galtondf$parent)
child<-as.numeric(galtondf$child)

plot(parent, child, pch=21, col="blue", bg="green",
     cex=0.2*galtondf$freq,xlab="parent", ylab="child")
```

![1568076044121](assets/1568076044121.png)

## 2. `pairs()`

-  변수 간의 관계를 차트로 그릴 수 있다.

```R
attributes(iris)

$names
[1] "Sepal.Length" "Sepal.Width"  "Petal.Length"
[4] "Petal.Width"  "Species"     

$class
[1] "data.frame"

$row.names
  [1]   1   2   3   4   5   6   7   8   9  10  11
 [12]  12  13  14  15  16  17  18  19  20  21  22
 [23]  23  24  25  26  27  28  29  30  31  32  33
 [34]  34  35  36  37  38  39  40  41  42  43  44
 [45]  45  46  47  48  49  50  51  52  53  54  55
 [56]  56  57  58  59  60  61  62  63  64  65  66
 [67]  67  68  69  70  71  72  73  74  75  76  77
 [78]  78  79  80  81  82  83  84  85  86  87  88
 [89]  89  90  91  92  93  94  95  96  97  98  99
[100] 100 101 102 103 104 105 106 107 108 109 110
[111] 111 112 113 114 115 116 117 118 119 120 121
[122] 122 123 124 125 126 127 128 129 130 131 132
[133] 133 134 135 136 137 138 139 140 141 142 143
[144] 144 145 146 147 148 149 150
```

```R
pairs(iris[, 1:4])
```

![1568076304837](assets/1568076304837.png)

```R
pairs(iris[iris$Species=="setosa", 1:4])
```

![1568076369189](assets/1568076369189.png)

## 3. 3차원 산점도

`scatterplot3d(밑변, 오른쪽변 컬럼명, 왼쪽변 컬럼명)`

```R
install.packages("scatterplot3d")
library(scatterplot3d)
levels(iris$Species)
iris_setosa = iris[iris$Species=='setosa', ]
iris_versicolor = iris[iris$Species=='versicolor', ]
iris_virginica = iris[iris$Species=='virginica', ]
d3 <- scatterplot3d(iris$Petal.Length, iris$Sepal.Length,
      iris$Sepal.Width, type='n')  #type='n'은 기본 산점도를 표시하지 않음
```

![1568078100446](assets/1568078100446.png)

## 4. 데이터 전처리 도구

- 데이터 분석 프로젝트에서는 70%이상의 시간을 데이터 변환과 조작, 필터링 등 전처리 작업에 소요

  - 데이터 전처리에 사용되는 유용한 패키지 : `plyr`, `dplyr`, `reshape`, `reshape2`패키지

    

  ### 1. plyr

- 두개 이상의 데이터프레임을 대상으로 key값을 이용하여 merge, 함수적용 , 요약 집계등의 기능을 제공

```R
install.packages("plyr")
library(plyr)
x<-data.frame(id=c(1,2,3,4,5), 
              height=c(160, 171, 173, 162, 165))
y<-data.frame(id=c(5, 1, 3, 2, 4), 
              weight=c(55, 73, 60, 57, 75))

# join() : 두 데이터프레임을 merge
xyjoin <- join(x, y, by="id")
xyjoin

> xyjoin
  id height weight
1  1    160     73
2  2    171     57
3  3    173     60
4  4    162     75
5  5    165     55

x<-data.frame(id=c(1,2,3,4,6), 
              height=c(160, 171, 173, 162, 165))
leftjoin <- join(x, y, by="id")   #왼쪽 데이터 프레임의 키값을 기준으로 merge
leftjoin    #키에 join할 데이터가 없으면 NA로 출력

> leftjoin    #키에 join할 데이터가 없으면 NA로 출력
  id height weight
1  1    160     73
2  2    171     57
3  3    173     60
4  4    162     75
5  6    165     NA


innerjoin <- join(x, y, by="id", type="inner")
innerjoin   #innerjoin은 두 데이터프레임에서 키값이 있는 경우에만 조인을 수행

> innerjoin   #innerjoin은 두 데이터프레임에서 키값이 있는 경우에만 조인을 수행
  id height weight
1  1    160     73
2  2    171     57
3  3    173     60
4  4    162     75

fulljoin <- join(x, y, by="id", type="full")
fulljoin   #키 값이 존재하는 전체 관측치를 대상으로 조인 수행, 키에 join할 데이터가 없으면 NA로 출력

> fulljoin   #키 값이 존재하는 전체 관측치를 대상으로 조인 수행, 키에 join할 데이터가 없으면 NA로 출력
  id height weight
1  1    160     73
2  2    171     57
3  3    173     60
4  4    162     75
5  6    165     NA
6  5     NA     55

x<-data.frame(key1=c(1,1, 2,2, 3), 
              key2=c('a', 'b', 'c','d', 'e'),
              val1 = c(10,20,30,40,50))

y<-data.frame(key1=c(3, 2, 2, 1, 1), 
              key2=c('e', 'd', 'c','b', 'a'),
              val1 = c(500,300,400,100,200))

xyjoin <- join (x, y, by=c(key1, key2))
xyjoin

> xyjoin
  id height weight
1  1    160     73
2  2    171     57
3  3    173     60
4  4    162     75
5  5    165     55
```

### 2. `ddply()`

- dplyr 패키지 -데이터 전처리( 조건 필터, 그룹핑,  함수적용, 변환, 집계연산, 정렬,.....)
- `filter()` 조건에 맞는 데이터셋 추출, 행추출
- `select()` 데이터 셋을 대상으로 컬럼을 선택하는 기능
- `mutate()` 데이터 넷의 새로운 컬럼을 추가하는 기능
- `arrange()` 데이터 셋의 특정 컬럼으로 정렬하는 기능
- `summarise()` 데이터 셋의 특정 컬럼으로 요약집계 기능

```R
#apply(vec, func) - 결과는 벡터, 배열, 리스트
#lapply(vec|list, func) - 결과는  리스트
#sapply(vec , func) - 결과는 벡터, 배열, 행렬 반환
#tapply() - 데이터 셋에 집단 변수(이산형 범주)를 대상으로 그룹별 함수 적용
#tapply(vec, 집단변수, 함수)

names(iris)
unique(iris$Species)
tapply(iris$Sepal.Length, iris$Species, mean)
sd_iris <- tapply(iris$Sepal.Length, iris$Species, sd)
str(sd_iris)


#ddply() - 데이터 셋에 집단 변수(이산형 범주)를 대상으로 그룹별 함수를 여러개  적용할 수 있습니다.
#ddply(데이터 셋, 집단변수, 요약집계, 컬럼명=함수(변수)) - 결과를 data.frame타입으로 반환

avg_df <- ddply(iris, .(Species), summarise, avg=mean(Sepal.Length))
avg_df
str(avg_df)

result <-ddply(iris, .(Species), summarise, avg=mean(Sepal.Length)
                 , std = sd(Sepal.Length), max=max(Sepal.Length),
                  min=min(Sepal.Length))
result
str(result)
```

```R

exam.csv#################################################################
id,class,math,english,science
1,1,50,98,50
2,1,60,97,60
3,1,45,86,78
4,1,30,98,58
5,2,25,80,65
6,2,50,89,98
7,2,80,90,45
8,2,90,78,25
9,3,20,98,15
10,3,50,98,45
11,3,65,65,65
12,3,45,85,32
13,4,46,98,65
14,4,48,87,12
15,4,75,56,78
16,4,58,98,65
17,5,65,68,98
18,5,80,78,90
19,5,89,68,87
20,5,78,83,58

exam<-read.csv("./datas/exam.csv")

print(exam)
str(exam)

# %>% 파이프 연산자 (다음 함수의 입력값으로 전달)
# class가 1인 record(행)추출
class1 <- exam %>% filter(class==1)
print(class1)

# class가 1을 제외한 record(행)추출
other_class <- exam %>% filter(class!=1)
print(other_class)

#class가 1이면서 수학점수는 50이상인 행을 추출
class1_math50 <- exam %>% filter(class==1 & math>50 )
print(class1_math50)

#class가 1,3,5인 행만 추출
odd_class <- exam %>% filter(class  %in% c(1, 3, 5) )
print(odd_class)

#영어점수 컬럼값만 추출
e_jumsu <- exam %>% select(english)
print(e_jumsu)

#수학점수 제외하고 모든 컬럼 추출
all_column <- exam %>% select(-math)
print(all_column)

#class가 1이면서 영어점수 컬럼값만 1행에서~3행까지 출력
print(exam %>% filter(class==1)  %>% select(english) %>% head(3))
  
#수학점수를 기준으로 오름차순 정렬된 결과를 변수에 저장하고 출력
asc_math <- exam  %>%  arrange(math) 
print(asc_math)

#수학점수를 기준으로 내림차순 정렬된 결과를 변수에 저장하고 출력
desc_math <- exam  %>%  arrange(desc(math))
print(desc_math)

# 1차 정렬은 class의 오름차순, 2차 정렬은 수학점수의 내림차순으로 정렬
order_math <- exam  %>%  arrange(class, desc(math))
print(order_math)

#총점(수학+영어+과학) 열을 추가
new_exam <- exam %>% mutate(total= math+english+science) 
print( new_exam )

#평균 열 추가
avg_exam <- exam  %>% mutate(total= math+english+science, 
                      mean=(math+english+science)/3 ) 
print( avg_exam )


#pass이름의 열을 추가 (평균이 60점이상이면 "pass"값, 
                      60점미만이면 "fail"값을 가짐)
pass <-  exam  %>% mutate(mean=(math+english+science)/3)   
           %>% mutate(pass=ifelse(mean >= 60 , "pass", "fail" ) ) 
print( pass )


#추가된 평균 컬럼으로 내림차순 정렬
avg_desc_exam <-  exam  %>% mutate(mean=(math+english+science)/3)  %>% arrange(mean)
print( avg_desc_exam)
```

### 3. `hflights`

```R
install.packages("hflights")
library(hflights)
#2011년도 미국 휴스턴 출발 모든 비행기의 이착률 정보 기록
#대략 22만건, 21개의 변수(컬럼)로 구성된 데이터셋
str(hflights)
flights_df <- tbl_df(flights) #현재 R콘솔 창크기에서 볼수 있는 만큼 10개행? 8개 컬럼?
flights_df

#hflights데이터셋으로부터 1월의 2일 모든 비행기의 이착률 정보 추출
filter(hflights, Month==1 & DayofMonth==2)

#hflights데이터셋을 년, 월, 출발시간, 도착시간순으로 오름차순 정렬
arrange(hflights, Year, Month, DepTime, ArrTime)

#hflights데이터셋을 년(오름차순), 월(오름차순), 출발시간(내림차순), 도착시간(오름차순) 정렬
arrange(hflights, Year, Month, desc(DepTime), ArrTime)

#hflights데이터셋으로부터 년, 월, 출발시간, 도착시간 컬럼만 검색
select(hflights,Year, Month, DepTime, ArrTime)

#hflights데이터셋으로부터 출발지연시간과 도착지연시간과의 차이를 계산한 컬럼 추가
select(mutate(hflights, gain=ArrDelay-DepDelay,
                 gain_per_hour = gain(AirTime/60)), 
       Year, Month, ArrDelay, DepDelay, gain, gain_per_hour)


#hflights데이터셋으로부터 도착 시간에 대한 평균, 표준편차 계산
summarise(hflights, cnt=n(), delay=mean(AirTime, na.rm=T))
summarise(hflights, arrTimeSd = sd(AirTime, na.rm=T),
          arrTimeVar = var(AirTime, na.rm=T))
```



### 4. `Group by`

```R
exam <-read.csv("./data/exam.csv")
print(exam)
summary_exam <- exam %>% summarise(mean_math=mean(math), 
                                       sum_math=sum(math),
                                       median_math =median(math),
                                       sd_math=sd(math),
                                       min_math=min(math),
                                       max_math=max(math),
                                       n=n()) 
print(summary_exam)
#그룹핑 : group_by()
#클래스별로 기초통계값을 출력
group_summary  <- exam %>% group_by(class) %>% summarise(mean_math=mean(math), 
                                       sum_math=sum(math),
                                       median_math =median(math),
                                       sd_math=sd(math),
                                       min_math=min(math),
                                       max_math=max(math),
                                       n=n())
print(group_summary)
```



### 5.` ggplot2`

```R
install.packages("ggplot2")
library(ggplot2)
#자동차 배기량에 따라 고속도록 연비 ...데이터 셋
mpg <- as.data.frame(ggplot2::mpg)
print(mpg)
str(mpg)
#displ 배기량
#manufaturer 제조사
#cty 도시연비
#hwy 고속도로 연비
#class차종
library(dplyr)
Quiz> 회사별로 분리, suv 추출, 통합 연비(도시연비+고속도로 연비) 변수 생성, 
통합 연비 평균 산출, 내림차순 정렬, 1~5위까지 출력
 mpg %>% group_by(manufacturer) %>% filter(class="suv")
     %>% mutate(tot=(cty+hwy)/2) %>% summarise(mean_tot=mean(tot))
     %>% arrange(desc(mean_tot)) %>% head(5)


Quiz> 어떤 회사에서 "compact"(경차) 차종을 가장 많이 생산하는지 알아보려고 합니다. 
각 회사별로 "compact" 차종을 내림차순으로 정렬해 출력하세요
result <- mpg %>% filter(class="compact") %>% group_by(manufacturer)
         %>% summarise(count=n()) 
result %>% arrange(desc(count)) 
```



### 6. `RJDBC`

- 개념 : 
  - OracleDB로부터 R실행환경(메모리)로 데이터 가져오기
  - RJDBC::JDBC("driver이름", "driver가 존재하는 클래스경로", "DB에서 문자열 처리")
  - `dbConnect(driver객체, DB_Url, user, password)`
  - `dbGetQuery(connection객체,  select sql문장)`

```R
install.packages("RJDBC")
library(RJDBC)
library(rJava)

drv <- JDBC("oracle.jdbc.OracleDriver",
            classPath="C:/app/student/product/11.2.0/dbhome_1/jdbc/lib/ojdbc6.jar",
            identifier.quote="'")

con <- dbConnect(drv, "jdbc:oracle:thin:@localhost:1521:orcl", "hr", "oracle")
rs <- dbGetQuery(con, "select tname from tab")
View(rs)
```

![1568092882231](assets/1568092882231.png)

### 7. 관계도 :`igraph()`

```R
install.packages("igraph")
library(igraph)
g1 <- graph(c(1, 2, 2, 3, 2, 4, 1, 4, 5, 5, 3, 6))
print(g1)
plot(g1)
str(g1)
```

![1568093994816](assets/1568093994816.png)

```R
name<-c("세종대왕", "일지매 부장", "김유신 과장", "손흥민 대리", "류현진 대리",
        "이순신 부장", "유관순 차장", "신사임당 대리", "강감찬 부장"
        , "광개토 과장", "정몽주 대리")
pemp <- c("세종대왕", "세종대왕", "일지매 부장" , "김유신 과장", "김유신 과장",
          "세종대왕",  "이순신 부장", "유관순 차장",  "세종대왕" , "강감찬 부장"
          , "광개토 과장")

emp <- data.frame(이름=name, 상사이름=pemp)
print(emp)
g <- graph.data.frame(emp, direct=T)
plot(g, layout=layout.fruchterman.reingold,
     vertex.size=8, edge.arrow.size=0.5)
```

![1568096048063](assets/1568096048063.png)

### 8. `reshape` 패키지

- 데이터 셋의 구성이 구분변수(identifier variable)에 의해서 특정 변수가 분류된 경우  데이터 셋의 모양을 변경하는 패키지
  - 구분변수(identifier variable) : 데이터 셋에 1개 이상으로 분류되는 집단변수
  - 측정변수(measured variable): 구분변수에 의해서 구분되는 변수
- 데이터 파일을 가져오는 경우 컬럼명이 없으면 기본적으로 V1, V2, V3...
  형식으로 기본 컬럼명이 적용되므로 데이터 셋의 컬럼명을 변경하려면
  rename() 함수를 사용합니다.
  - reshape(), melt() : 구분변수를 기분으로 측정변수를 분류하여 새로운컬럼을 생성
  - reshape(data.frame, varying="반복되는 측정 색인",
            v.names="반복되는 측정값", timevar="반복되는 측정 시간",
            idvar="1개 이상의 값으로 분류되는 변수", direction="wide/long")
    - wide는 기준변수와 관련 변수가 1:n 관계로 관측치가 구성
    - long은 기준변수와 관련 변수가 1:1 관계로 관측치가 구성

```R
install.packages("reshape")
library(reshape)
#데이터 파일을 가져오는 경우 컬럼명이 없으면 기본적으로 V1, V2, V3...
형식으로 기본 컬럼명이 적용되므로 데이터 셋의 컬럼명을 변경하려면
 rename() 함수를 사용합니다.

result<-read.csv("./datas/reshape.csv", header=FALSE)
head(result)
result<-rename(result,c(V1="total", V2="num1", V3="num2", V4="num3"))

 total num1 num2 num3
1   5.1  1.4  0.2  3.5
2   4.9  1.4  0.2  3.0
3   4.7  1.3  0.2  3.2
4   4.6  1.5  0.2  3.1
5   5.0  1.4  0.2  3.6
6   5.4  1.7  0.4  3.9 

data('Indometh')  #항염증제에 대한 약물동태학에 관한 데이터 셋
str(Indometh)  #생체내에서 약물의 흡수, 분포, 비축, 대사, 배설의 과정을 연구
                #Subject(실험대상), time(약물 투여시간:hr), conc(농도:ml/mcg)
Indometh   #long형식

# 기준변수 : timevar="time", idvar="Subject"
# 관측변수 : v.names="conc"
# 실험대상1을 기준으로 약물투여시간 0.25에서 8까지의 ...농도를 
wide <- reshape(Indometh, v.names="conc", timevar="time", idvar="Subject", direction="wide")
wide

reshape(wide, direction="long")

#varying="반복되는 측정 색인" 사용
long <- reshape(wide, idVar="Subject", varying=2:12,
                v.names="conc",  direction="long" )
str(long)

#melt(data, id="기준변수", measured="측정변수")
#melt는 구분변수를 기준으로 측정변수를 긴형식에서 넓은 형식으로 변경

smiths
#기준변수 ("subject", "time")를 이용하여 측정변수 분류
melt(smiths, id=c("subject", "time")) 

melt(smiths, id=c("subject", "time"), measured=c("age"))

melt(smiths, id=c("subject", "time"), measured=c("age", "weight", "height"))

melt(smiths, id=c(1:2), na.rm=T)
 

#cast() : 측정변수에 집합함수를 적용
#cast(data, 포뮬러 식 , ~측정변수, 집합함수)
smithsm <- melt(smiths, id=c(1:2))
smithsm
                 
cast(smithsm, subject= ~ variable) #subject와 time 변수를 이용하여 측정변수(age, weight, height)를 분류



#Indometh 데이터셋으로부터 subject와 time을 구분변수로 long 형식으로 변환


#Indometh 데이터셋으로부터 subject구분변수로 특정변수 농도의 합계 통계량 계산


#Indometh 데이터셋으로부터 subject구분변수로 특정변수 농도의 평균, 최소값~최대값 범위를 계산
```

### 9. 게임 매상 감소 원인 분석

```R
# CSV 파일을 읽어들이기
dau <- read.csv("./data/dau.csv", header = T, stringsAsFactors = F)
head(dau)
dpu <- read.csv("./data/dpu.csv", header = T, stringsAsFactors = F)
head(dpu)
install <- read.csv("./data/install.csv", header = T, stringsAsFactors= F)
head(install)


# DAU 데이터에 Install 데이터를 결합시키기 (merge함수)
 
join <- join(dau, install, by="user_id", type="full")
# 1차결합된 데이터에 DPU 데이터를 결합시키기 (merge함수)
 fulljoin <- join(join, dpu, by="user_id", type="full")

# 비과금 유저의 과금액에 0을 넣기 ( data[row,col]<-0)
fulljoin[is.na(fulljoin[, "payment"]), "payment"] <- 0

# 월 항목 추가   (data.frame객체$새컬럼변수 <- 추가될 데이터, mutate, cbind 등 이용)

# 추가된 월 항목으로 그룹핑후 과금액 집계 (ddply, aggregate, dplyr::group_by등 이용)

# 신규 유저인지 기존 유저인지 구분하는 항목의 새 컬럼변수 추가

# 그래프로 데이터 시각화 


# CSV 파일을 읽어들이기
dau <- read.csv("./data/dau.csv", header = T, stringsAsFactors = F)
head(dau)
dpu <- read.csv("./data/dpu.csv", header = T, stringsAsFactors = F)
head(dpu)
install <- read.csv("./data/install.csv", header = T, stringsAsFactors= F)
head(install)


# DAU 데이터에 Install 데이터를 결합시키기 (merge함수)
# 기준변수 ("user_id", "app_name")
dau.install <- merge(dau, install, by = c("user_id", "app_name"))
head(dau.install)

# 1차결합된 데이터에 DPU 데이터를 결합시키기 (merge함수)
# 기준변수 (("log_date", "app_name", "user_id") 
dau.install.payment <- merge(dau.install, dpu, 
                       by = c("log_date","app_name", "user_id"), 
                       all.x = T)
head(dau.install.payment, 20)
head(na.omit(dau.install.payment))

# 비과금 유저의 과금액에 0을 넣기 ( data[row,col]<-0)
#데이터객체[is.na(데이터객체$컬럼명)] <- 0
dau.install.payment$payment[is.na(dau.install.payment$payment)] <- 0
head(dau.install.payment, 20)

# 월 항목 추가   (data.frame객체$새컬럼변수 <- 추가될 데이터, mutate, cbind 등 이용)
dau.install.payment$log_month <-substr(dau.install.payment$log_date, 1, 7)
dau.install.payment$install_month <- substr(dau.install.payment$install_date, 1, 7)
head(dau.install.payment, 20)


# 추가된 월 항목으로 그룹핑후 과금액 집계 (ddply, aggregate, dplyr::group_by등 이용)
mau.payment <- ddply(dau.install.payment,
                     .(log_month, user_id, install_month), # 그룹화
                     summarize, # 집계 명령
                     payment = sum(payment) # payment 합계
                     )

head(mau.payment, 10)


# 신규 유저인지 기존 유저인지 구분하는 항목의 새 컬럼변수 추가
mau.payment$user.type <-  ifelse(mau.payment$install_month == mau.payment$log_month, "new", "old")

# 그래프로 데이터 시각화 

```

