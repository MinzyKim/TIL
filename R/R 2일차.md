# R 2일차

## 1. Vector 이어서

### 1. 패키지 다운로드 경로 확인

```R
.libPaths()
```

### 2. 벡터 요소에 access하는 방법

```R
t <- c("Sun","Mon","Tue","Wed","Thurs","Fri","Sat")
print(t[1])   #"Sun"
print(t[7])   #"Sat"
u <- t[c(2,3,6)]   #"Mon","Tue", "Fri"
print(u)

v <- t[c(TRUE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE)]
print(v)    # "Sun", "Fri"

x <- t[c(-2,-5)] #인덱스 요소를 제외하고 출력
print(x)    #"Sun", "Tue","Wed", "Fri","Sat"

y <- t[c(0,0,0,0,0,0,1)]  #index에 해당하는 요소 출력
print(y)   
```

```output
> t <- c("Sun","Mon","Tue","Wed","Thurs","Fri","Sat")
>print(t[1])   #"Sun"
[1] "Sun"
> print(t[7])   #"Sat"
[1] "Sat"
> u <- t[c(2,3,6)]   #"Mon","Tue", "Fri"
> print(u)
[1] "Mon" "Tue" "Fri"

> v <- t[c(TRUE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE)]
> print(v)    # "Sun", "Fri"
[1] "Sun" "Fri"
> x <- t[c(-2,-5)] #인덱스 요소를 제외하고 출력
> print(x)    #"Sun", "Tue","Wed", "Fri","Sat"
[1] "Sun" "Tue" "Wed" "Fri" "Sat"
> y <- t[c(0,0,0,0,0,0,1)]  #index에 해당하는 요소 출력
> print(y)    
[1] "Sun"
```

### 3. 벡터 연산 : 요소들간 연산 수행

```R
v1 <- c(3,8,4,5,0,11)
v2 <- c(4,11,2)
add.result <- v1+v2      # v1-v2 , v1*v2, v1/v2
print(add.result)


v1 <- c(3,8,4,5,0,11)
v2 <- c(4,11)        #(4, 11, 4, 11, 4, 11)
add.result <- v1+v2  #연산 대상 벡터요소개수가 가장 긴쪽에 맞춰서 요소가 recycling
print(add.result)  

nums <- c(3/2, 3%/%2, 5%%3,2^10,2**10)
print(nums)
print(( 0 %in% nums))
print(( 1024 %in% nums))
```

```output
> print(add.result)
[1]  7 19  6  9 11 13
```

```R
# 문제
*nums 벡터 요소중 10보다 큰 요소만 출력 (>, >=,==, !=, <, <= )

print(nums[nums>10])
 
*nums 벡터 요소중 짝수인 요소만 출력

print(nums[nums%%2==0]) 
```

#### 이름으로 벡터 요소 접근, 소트

```R
loc <- c("02", "031","062", "052")
str(loc)
names(loc)<-c("서울", "경기", "광주", "부산")
print(loc["경기"])  #이름으로 벡터 요소 접근 가능
str(loc)  

# 소트
v <- c(3,8,4,5,0,11, -9, 304)
sort.result <- sort(v)
print(sort.result)

revsort.result <- sort(v, decreasing = TRUE)
print(revsort.result)

v <- c("Red","Blue","yellow","violet")
sort.result <- sort(v)
print(sort.result)
```

```output
> print(loc["경기"])  #이름으로 벡터 요소 접근 가능
 경기 
"031" 
> str(loc)  
 Named chr [1:4] "02" "031" "062" ...
 - attr(*, "names")= chr [1:4] "서울" "경기" "광주" "부산"
> v <- c(3,8,4,5,0,11, -9, 304)
> sort.result <- sort(v)
> print(sort.result)
[1]  -9   0   3   4   5   8  11 304
> revsort.result <- sort(v, decreasing = TRUE)
> print(revsort.result)
[1] 304  11   8   5   4   3   0  -9
> v <- c("Red","Blue","yellow","violet")
> sort.result <- sort(v)
> print(sort.result)
[1] "Blue"   "Red"    "violet" "yellow"
```

### 4. 집합연산함수

```R
#집합연산함수(교집합, 합집합, 차집합, 부분집합, ..)
#identical( 객체1, 객체2) 두객체의 데이터 갯수, 순서도 일치
#union( 객체1, 객체2)
#intersect(객체1, 객체2)
#setdiff(객체1, 객체2)
#setequal(객체1, 객체2)

vec1 <- c(1, 2, 3, 4, 5)
vec2 <- c(10, 9, 8, 4, 5)
vec3 <- c(1, 2, 3, 4, 5)
print(identical(vec1,vec3))
print(identical(vec1,vec2))
vec4 <- c(5,3,4,1,2)
print(setequal(vec1,vec4))  #순서는 일치하지 않아도 요소들만 일치하면 true리턴
print(setequal(vec1,vec3))


print(union(vec1,vec2))
print(intersect(vec1,vec2))
print(setdiff(vec1,vec2))
```



## 2. Matrix

- 개념 :
  - 벡터를 여러 개 합친 형태로 2차원으로 데이터를 저장

- 특징 :
  - 동일한 데이터 유형만 저장
  - rbind()로 행을 추가할 수 있다.
  - cbind()로 컬럼을 추가할 수 있다.
  - 컬럼 이름을 지정, 조회하려면 colnames() 사용
  - 행이름 지정, 조회하려면 rownames() 사용

### 1. matrix 생성

```R
M <- matrix(c(3:14)) # 열 기준 2차원 데이터 구조
print(M)
str(M)

M1 <- matrix(c(3:14) nrow=3) # 열 기준 2차원 데이터 구조
print(M1)
str(M1)

M2 <- matrix(c(3:14), nrow = 4, byrow = TRUE) #행기준 2차원 데이터 구조
print(M2)
str(M2)
```

```output
> print(M)
      [,1]
 [1,]    3
 [2,]    4
 [3,]    5
 [4,]    6
 [5,]    7
 [6,]    8
 [7,]    9
 [8,]   10
 [9,]   11
[10,]   12
[11,]   13
[12,]   14
> str(M)
 int [1:12, 1] 3 4 5 6 7 8 9 10 11 12 ...
```

### 2. rbind, cbind

```R
x1 <- c(5, 40, 50:52)
x2 <-c(30, 5, 6:8)
M3 <- rbind(x1, x2)
print(M3)
class(M3)
str(M3)

M4 <- cbind(x1, x2)
print(M4)
str(M4)
class(M3)

M <- matrix(10:19, 2)  #2행?
print(M)
str(M)

#행과 열의 수가 일치하지 않으면 오류가 발생하며, 모자라는 데이터는 첫 번째 데이터부터 재사용하여 채운다
#행렬 객체 생성시 주어진 데이터의 길이는 행과 열의 행렬 수에 정확히 일치되어야 한다. (경고 발생)
M <- matrix(10:20, 2)   

rownames <- c("row1", "row2", "row3", "row4")
colnames <- c("col1", "col2", "col3")

M5 <- matrix(c(3:14), nrow = 4, byrow = TRUE, dimnames = list(rownames, colnames))
print(M5)
str(M5)


P1 <-cbind(M5, c(13,14,15,16)) #cbind()는  컬럼을 추가
print(P1)  #4행 4열

P2 <-rbind(M5, c(13,14,15))  #rbind() 는 행을 추가
print(P2) #5행 3열

print(M5+P1)  # 열 개수가 다름 error 발생
print(M5+P2)  # 행 개수가 다름 error 발생
```

### 3. matrix 요소 접근

```R
# Matrix 요소에 접근 - 변수[첨자, 첨자]
# 특정 행이나 특정 열만 접근하는 경우 변수명[행첨자, ], 변수명[, 열첨자] 형식으로 지정
print(M5[1,3])
print(M5[2,])  #2행 전체 요소에 접근
print(M5[,3])   #3열 전체 요소에 접근
print(M5["row1",])  #1행 전체 요소에 접근
print(M5[,"col3"])   #3열 전체 요소에 접근

```

### 4. matrix 연산

```R
# Matrix 연산
matrix1 <- matrix(c(3, 9, -1, 4, 2, 6), nrow = 2)
matrix2 <- matrix(c(5, 2, 0, 9, 3, 4), nrow = 2)
result <- matrix1 + matrix2
cat("Result of addition","\n")
print(result)

result <- matrix1 + 10
print(result)
print(length(result))  #전체 원소 개수 반환
print(nrow(result))  #행 수 반환
print(ncol(result))  #열 수 반환
```

### 5. base패키지의 apply함수

```R
#base패키지의 apply함수 apply(행렬객체, margin(1:행, 2:열), function)
f <- function(x) {  #사용자 정의 함수 
   x*c(1,2,3)
}
result <- apply(matrix1, 1, f)
print(result)

result <- apply(matrix(1:9, ncol=3), 2, f)
print(result)
```

